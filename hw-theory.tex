\documentclass[10pt,a4paper,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{stmaryrd}
\usepackage{comment}
\usepackage{cmll}
\usepackage{mathrsfs}
\usepackage{hyperref}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{proof}
\usepackage{tikz}
\usepackage{multicol}

\makeatletter
\newcommand{\dotminus}{\mathbin{\text{\@dotminus}}}

\newcommand{\@dotminus}{%
  \ooalign{\hidewidth\raise1ex\hbox{.}\hidewidth\cr$\m@th-$\cr}%
}
\makeatother

\usetikzlibrary{arrows,backgrounds,patterns,matrix,shapes,fit,calc,shadows,plotmarks}

\newtheorem{definition}{Определение}
\begin{document}

\begin{center}{\Large\textsc{\textbf{Теоретические домашние задания}}}\\
             \it Теория типов, ИТМО, совместно М3232-М3239 и M3332-M3339, весна 2024 года\end{center}

\section*{Домашнее задание №1: лямбда исчисление --- бестиповое и просто-типизированное}

\begin{enumerate}
\item Бесконечное количество комбинаторов неподвижной точки. Дадим следующие определения
$$\begin{array}{l}
L := \lambda abcdefghijklmnopqstuvwxyzr.r(thisisafixedpointcombinator)\\
R := LLLLLLLLLLLLLLLLLLLLLLLLLL\end{array}$$
В данном определении терм $R$ является комбинатором неподвижной точки: каков бы ни был терм
$F$, выполнено $R\ F =_\beta F\ (R\ F)$.
\begin{enumerate}
\item Докажите, что данный комбинатор --- действительно комбинатор неподвижной точки.
\item Пусть в качестве имён переменных разрешены русские буквы. Постройте аналогичное выражение
по-русски: с 33 параметрами и осмысленной русской фразой в терме $L$; покажите, что оно является
комбинатором неподвижной точки.
\end{enumerate}

\item Найдите необитаемый тип в просто-типизированном лямбда-исчислении (напомним: тип $\tau$ 
называется необитаемым, если ни для какого $P$ не выполнено $\vdash P : \tau$).

\item Напомним определение: комбинатор --- лямбда-выражение без свободных переменных. Также напомним:
$$\begin{array}{l}
S := \lambda x.\lambda y.\lambda z.x\ z\ (y\ z)\\
K := \lambda x.\lambda y.x\\
I := \lambda x.x
\end{array}$$

Известна теорема о том, что для любого комбинатора $X$ можно найти выражение $P$
(состоящее только из скобок, пробелов и комбинаторов $S$ и $K$), что $X =_\beta P$.
Будем говорить, что комбинатор $P$ \emph{выражает} комбинатор $X$ в базисе $SK$.

Косвенным аргументом (пояснением, но не доказательством!) в пользу этой теоремы являются 
два следующих соображения:
\begin{itemize}
\item теорема о замкнутости ИфИИВ: если $\vdash \varphi$, то $\vdash_\rightarrow \varphi$,
значит, если выражение имеет тип, то этот тип можно получить с помощью доказательства в
стиле Гильберта;
\item типы комбинаторов $S$ и $K$ --- это, соответственно, вторая и первая схемы аксиом.
\end{itemize}

Докажите тип следующих выражений как логическое высказывание с помощью
гильбертового вывода и, пользуясь этим доказательством как источником вдохновения, 
выразите комбинаторы в базисе $SK$:
\begin{enumerate}
\item $\lambda x.\lambda y.\lambda z.y$
\item $\lambda x.\lambda y.\lambda z.y x z$
\item $\overline{1}$
\item $Not$
\item $Xor$
\item $InR$
\end{enumerate}

\item Покажите на основании следующего преобразования полноту комбинаторного базиса SKI
(проведите полное рассуждение по индукции, из которого будет следовать отсутствие 
в результате других термов, кроме SKI, бета-эквивалентность
и определённость результата для всех комбинаторов $\sigma$):

$$[\sigma]=\left\{\begin{array}{ll}
x, & \sigma = x\\
\left[\varphi\right]\ [\psi], & \sigma = \varphi\ \psi\\
K\ [\varphi], & \sigma = \lambda x.\varphi,\quad x \notin FV(\varphi)\\
I, & \sigma = \lambda x.x \\
\left[\lambda x.\left[\lambda y.\varphi\right]\right], & \sigma = \lambda x.\lambda y.\varphi,\quad x \in FV(\varphi), x \ne y\\
S\ [\lambda x.\varphi]\ [\lambda x.\psi], & \sigma = \lambda x.\varphi\ \psi,\quad x \in FV(\varphi)\cup FV(\psi)
\end{array}\right.$$

Заметим, что данные равенства объясняют смысл названий комбинаторов:

\begin{tabular}{ll}
$S$ & verSchmelzung, <<сплавление>> \\
$K$ & Konstanz \\
$I$ & Identit\"at
\end{tabular}

\item Покажите, что следующая система комбинаторов образует полный базис в бестиповом
лямбда-исчислении, но соответствующая им система аксиом в исчислении гильбертового типа
не образует полного базиса для импликативного фрагмента:

$$\begin{array}{l}
I := \lambda x.x\\
K := \lambda x.\lambda y.x\\
S' := \lambda i.\lambda x.\lambda y.\lambda z.i\ (i\ ((x\ (i\ z))\ (i\ (y\ (i\ z)))))
\end{array}$$

Указание: покажите невыводимость $(\varphi \rightarrow \varphi \rightarrow \psi) \rightarrow (\varphi \rightarrow \psi)$.

\item Напомним определение аппликативного порядка редукции:
редуцируется самый левый из самых вложенных редексов. Например, в случае выражения
$(\lambda x.I\ I)\ (\lambda y.I\ I)$ самые вложенные редексы --- применения $I\ I$:

$$(\lambda x.\underline{I\ I})\ (\lambda y.\underline{I\ I})$$

и надо выбрать самый левый из них:

$$(\lambda x.\underline{I\ I})\ (\lambda y.I\ I)$$
\begin{enumerate}
\item Проведите аппликативную редукцию выражения $2\ 2$.
\item Докажите или опровергните, что параллельная бета-редукция из теоремы Чёрча-Россера не медленнее 
(в смысле количества операций для приведения выражения к нормальной форме), чем нормальный порядок 
редукции с мемоизацией.
\item Найдите лямбда-выражение, которое редуцируется медленнее при нормальном порядке редукции,
чем при аппликативном, даже при наличии мемоизации.
\end{enumerate}

\item Напомним определение бета-редукции. $A \rightarrow_\beta B$, если:
\begin{itemize}
\item $A \equiv (\lambda x.P)\ Q$, $B \equiv P\ [x := Q]$, при условии свободы для подстановки;
\item $A \equiv (P\ Q)$, $B \equiv (P'\ Q')$, при этом $P \rightarrow_\beta P'$ и $Q = Q'$, либо $P = P'$ и $Q \rightarrow_\beta Q'$;
\item $A \equiv (\lambda x.P)$, $B \equiv (\lambda x.P')$, и $P \rightarrow_\beta P'$.
\end{itemize}

\begin{enumerate}
\item Найдите лямбда-выражение, бета-редукция которого не может быть произведена из-за нарушения
правила свободы для подстановки (для продолжения редукции потребуется производить переименование
связанных переменных). Поясните, какое ожидаемое ценное свойство будет нарушено, если ограничение
правила проигнорировать.
\item Покажите, что недостаточно наложить требования на исходное выражение, и свобода для подстановки
может быть нарушена уже в процессе редукции исходно полностью корректного лямбда-выражения.
\end{enumerate}

\item Будем говорить, что выражение $A$ находится в \emph{слабой заголовочной нормальной форме} (WHNF),
если оно не имеет вид $A \equiv (\lambda x.P)\ Q$ (то есть, самый верхний терм его не является редексом).
Выражение находится в \emph{заголовочной нормальной форме} (HNF), когда его верхний терм --- не редекс и не лямбда-абстракция
с бета-редексами в теле.
\begin{enumerate}
\item Приведите нормальным порядком редукции выражение $2\ 2$ в СЗНФ.
\item Приведите нормальным порядком редукции выражение $Y\ (\lambda f.\lambda x.(IsZero\ x)\ 1\ (x \cdot f(x-1)))\ 3$ в СЗНФ.
\item Верно ли, что <<нормальность>> формы выражения может в процессе редукции только усиливаться
(никакая --- слабая заголовочная Н.Ф. --- заголовочная Н.Ф. --- нормальная форма)?
\end{enumerate}

\item Как мы уже разбирали, $\not\vdash x\ x:\tau$ в силу дополнительных ограничений
правила
$$\infer[x \notin FV(\Gamma)]{\Gamma, x:\tau\vdash x:\tau}{}$$

Найдите лямбда-выражение $N$, что $\not\vdash N:\tau$ в силу ограничений правила
$$\infer[x \notin FV(\Gamma)]{\Gamma \vdash \lambda x.N:\sigma\to\tau}{\Gamma, x:\sigma \vdash N:\tau}$$

%\item Верно ли, что $S = B(BW)(BBC)$? Если нет, то как правильно?

\end{enumerate}

\section*{Домашнее задание №2: задачи типизации лямбда исчисления}

\begin{enumerate}
\item Рассмотрим подробнее отличия исчисления по Чёрчу и по Карри. 
Определим точно бета-редукцию в исчислении по Чёрчу: $A \rightarrow_\beta B$, если

\begin{tabular}{ll}
$A = (\lambda x^\sigma.P)\ Q$, & $B = P [x := Q]$\\
$A = P\ Q$, & $B = P\ Q'$ или $B = P'\ Q$ при $P \rightarrow_\beta P'$ и $Q \rightarrow_\beta Q'$\\
$A = \lambda x^\sigma.P$, & $B = \lambda x^\sigma.P'$ при $P \rightarrow_\beta P'$
\end{tabular}
\begin{enumerate}
\item Покажите, что в исчислении по Карри не выполняется даже <<ограниченное>> свойство распространения типизации
(subject expansion): 
если $\vdash_\text{к} M:\sigma$, $M \twoheadrightarrow_\beta N$ и $\vdash_\text{к} N:\tau$,
то необязательно, что $\sigma=\tau$.
\item Покажите, что в исчислении по Чёрчу <<полное>> свойство распространения типизации также не выполняется:

\begin{center}найдутся такие $M,N,\sigma$, что $\vdash_\text{ч} N:\sigma$, $M\twoheadrightarrow_\beta N$, но $\not\vdash_\text{ч} M:\sigma$.\end{center}

Но при этом в исчислении по Чёрчу выполнено <<ограниченное>> свойство распространения типизации:

\begin{center}если $\vdash_\text{к} M:\sigma$, $M \twoheadrightarrow_\beta N$ и $\vdash_\text{к} N:\tau$,
то тогда $\sigma=\tau$.\end{center}
\end{enumerate}

\item Покажите, что никакие связки в ИИВ не выражаются друг через друга: то есть, нет такой формулы $\varphi(A,B)$ из языка 
интуиционистской логики, не использующей связку $\star$, что $\vdash A \star B \rightarrow \varphi(A,B)$ и $\vdash\varphi(A,B) \rightarrow A \star B$.
Покажите это для каждой связки в отдельности:
\begin{enumerate}
\item конъюнкция;
\item дизъюнкция;
\item импликация;
\item отрицание.
\end{enumerate}

\item Рассмотрим алгоритм построения системы уравнений, а именно случай, когда рассматривается два разных вхождения
одинакового по тексту применения. Например, $(x\ x)\ (x\ x)$ имеет два разных вхождения одной и той же аппликации
$x\ x$. Всегда ли для корректной работы алгоритма достаточно одной типовой переменной $\beta_{xx}$ для этих двух вхождений, 
или нужны две разные $\beta^L_{xx}$ и $\beta^R_{xx}$? 
Примечание: при одной переменной для обоих аппликаций система в данном случае, очевидно, несовместна: 
$\beta_{xx} \ne \beta_{xx} \rightarrow \sigma$.
Но контрпримером это не является, поскольку типа у данного выражения всё равно нет.

\item Предложим альтернативные аксиомы для конъюнкции:

$$\infer[\text{Введ. }\with]{\Gamma\vdash \alpha\with \beta}{\Gamma\vdash \alpha\ \ \ \Gamma\vdash \beta}\quad\quad
  \infer[\text{Удал. }\with]{\Gamma\vdash \gamma}{\Gamma\vdash \alpha\with \beta\ \ \ \Gamma, \alpha, \beta\vdash \gamma}$$

\begin{enumerate}
\item Предложите лямбда-выражения, соответствующие данным аксиомам; поясните, как данные выражения 
абстрагируют понятие <<упорядоченной пары>>.
\item Выразите изложенные в лекции аксиомы конъюнкции через приведённые в условии.
\item Выразите приведённые в условии аксиомы конъюнкции через изложенные в лекции.
\end{enumerate}

\item Постройте систему уравнений для $Y$-комбинатора и примените к ней алгоритм унификации (ожидается,
что система окажется несовместной).
\end{enumerate}

\begin{enumerate}
\item Найдите $\llbracket\alpha\rightarrow\alpha\rrbracket$.
\item Найдите $\llbracket(\alpha\rightarrow\alpha)\rightarrow\alpha\rrbracket$.
\item Покажите, что SN --- насыщенное (постройте полноценное рассуждение по индукции для п.2 определения).
\item Покажите, что если $\mathcal{A}$ и $\mathcal{B}$ насыщены, то $\mathcal{A}\rightarrow\mathcal{B}$ насыщенное.

\item Покажите, что построенная на лекции простая модель для ИИП второго порядка неполна.
\item Напомним, что мы можем задать $\exists p.\varphi$ как $\forall q.(\forall p.\varphi\rightarrow q)\rightarrow q$
(где $q$ --- некоторая свежая переменная).
Покажите, что правила для квантора существования могут быть выведены из такого определения.
\item Требуется ли свобода для подстановки в правилах с квантором?

    \[ \dfrac{\Gamma\vdash\varphi[p := \theta]}{\Gamma\vdash\exists p.\varphi} \qquad
        \dfrac{\Gamma\vdash\forall p.\phi}{\Gamma\vdash\phi[p:=\theta]} \]

Если да --- приведите пример доказуемой при отсутствии свободы для подстановки, но некорректной формулы. 
Если нет --- предложите доказательство корректности правил при любых подстановках.

\item Пусть $\Gamma\vdash\varphi$. Всегда ли можно перестроить доказательство $\varphi$, добавив ещё одну гипотезу:
$\Gamma,\psi\vdash\varphi$? Если нет, каковы могли бы быть ограничения на $\psi$?

\item Пусть $\Gamma\vdash\forall x.\varphi$. Верно ли тогда, что $\Gamma\vdash\forall y.\varphi[x := y]$? 
Если это неверно в общем случае, возможно, это верно при каких-то ограничениях? В случае наличия ограничений
приведите надлежащие контрпримеры.

\item Перенесите в систему $F$ из бестипового лямбда-исчисления следующие функции --- иными словами,
постройте их обобщение для системы $F$ (приведите обобщённое выражение, укажите его тип и докажите его).
Например, можно рассмотреть $I = \Lambda \pi.\lambda p^\pi.p \rightarrow p$. 
\begin{enumerate}
\item S, K.
\item инъекции и $case$ (операции с алгебраическим типом);
\item истина, ложь, исключающее или;
\item черчёвский нумерал (он должен иметь тип $\forall\alpha.(\alpha\rightarrow\alpha)\rightarrow(\alpha\rightarrow\alpha)$) и инкремент;
\item возведение в степень: $\lambda m.\lambda n.n\ m$;
\item вычитание единицы (трюк зуба мудрости) и вычитание.
\end{enumerate}
\end{enumerate}

\section*{Домашнее задание №4: экзистенциальные типы, типовая система Хиндли-Милнера}
\begin{enumerate}
\item Постройте экзистенциальный тип для очереди, и реализуйте его с помощью двух стеков.
Реализацию напишите на Хаскеле, используя AbstractStack с лекции как АТД стека 
(возможно, этот пример надо будет расширить нужными вам методами), и реализуйте 
какой-нибудь простой классический алгоритм с её помощью. Как, интересно, осуществить
инстанциацию вложенного абстрактного типа данных? Придумайте.

Как с помощью двух стеков можно реализовать очередь со средним временем доступа $\Theta(1)$:
входные значения кладём во входной стек, выходные достаём из выходного, при исчерпании ---
переносим всё из входного в выходной:

\begin{tabular}{lll}
Входной стек & Выходной стек & Действие\\
$[]\rightarrow[1]$ & $[]$ & $push\ 1$\\
$[1]\rightarrow[3;1]$ & $[]$ & $push\ 3$\\
$[3;1]\rightarrow[]$ & $[]\rightarrow[1;3]\rightarrow[3]$ & $pull$\\
$[]\rightarrow[5]$ & $[3]$ & $push\ 5$
\end{tabular}

\item Выразите дизъюнкцию через квантор существования в ИИП 2 порядка, а также алгебраический тип через экзистенциальный.

\item Покажите, что если $rk(\sigma,1)$, то для выражения $\sigma$ найдётся эквивалентное $\sigma'$ с поверхностными
кванторами. 

\item Покажите, что в предыдущем задании также имеется изоморфизм типов: существует биективная функция $\sigma\rightarrow\sigma'$,
которую можно выразить лямбда-выражениями.

\item Рассмотрим QuickSort:
\begin{verbatim}
let rec quick l =  match l with
    [] -> []
  | l1 :: ls -> List.filter (fun x -> x < l1) ls @ [l1] @ List.filter (fun x -> x >= l1)
\end{verbatim}

Укажите полные типовые схемы в системе HM для всех функций, участвующих в данном примере (тип списка раскрывать не надо).

\item Заметим, что список --- это <<параметризованные>> числа в 
аксиоматике Пеано. Число --- это длина списка, а к каждому штриху мы присоединяем какое-то значение.
Операции добавления и удаления элемента из списка --- это операции прибавления и вычитания
единицы к числу.

Рассмотрим тип <<бинарного списка>>:

\begin{verbatim}
type 'a bin_list = Nil | Zero of (('a*'a) bin_list) | One of 'a * (('a*'a) bin_list);;
\end{verbatim}

Заметим, что здесь мы рассматриваем двоичную запись числа (чередующиеся \verb!Zero! и \verb!One!) ---
двоичную запись длины бинарного списка, и элемент двоичной записи номер $n$ хранит $2^n$ или $2^n+1$ 
значение (в зависимости от типа элемента). Например, 5-элементный список:

\begin{verbatim}
One ("a", Zero (One ((("b","c"),("d","e")), Nil)))
\end{verbatim}

По идее, операция добавления элемента к списку записывается на языке Окамль вот так 
(сравните с прибавлением 1 к числу в двоичной системе счисления):

\begin{verbatim}
let rec add elem lst = match lst with
    Nil -> One (elem,Nil)
  | Zero tl -> One (elem,tl)
  | One (hd,tl) -> Zero (add (elem,hd) tl)
\end{verbatim}

Однако, тип этой функции Окамль вывести автоматически не может, его надо указывать явно,
чтобы код скомпилировался:

\begin{verbatim}
let rec add : 'a . 'a -> 'a bin_list -> 'a bin_list = fun elem lst -> match lst with
\end{verbatim}

\begin{enumerate}
\item Какой тип имеет \verb!add! в (расширенной) системе $F$ (напомним, поскольку функция рекурсивна,
она должна использовать Y-комбинатор в своём определении)?
Считайте, что семейство типов \verb!bin_list 'a! предопределено и обозначается как $\tau_\alpha$.
Также считайте, что определены функции roll и unroll с надлежащими типами.
Какой ранг имеет тип этой функции? Почему этот тип не выразим в типовой системе Хиндли-Милнера?
\item Предложите функции для печати списка и для удаления элемента списка (головы).
\item Предложите функцию для эффективного соединения двух списков (источник для 
вдохновения --- сложение двух чисел в столбик).
\item Предложите функцию для эффективного выделения $n$-го элемента из списка.
\end{enumerate}

\item Рассмотрим следующий код на Окамле, содержащий определения чёрчевских нумералов
и некоторых простых операций с ними:

\begin{verbatim}
let zero = fun f x -> x;;
let plus1 a = fun f -> fun x -> a f (f x);;
let power m n = n m;;

let two = plus1 (plus1 zero);;
let two2 = fun f x -> f (f x);;

let e  = power two two;;          (* не компилируется *)
let e2 = power two2 two2;;        (* компилируется и работает *)
\end{verbatim}

Разберите вывод типов в этом фрагменте (относительно типовой системы Хиндли-Милнера) и поясните, почему:
\begin{enumerate}
\item определение $e2$ компилируется и работает (предъявите доказательство типа в системе HM);
\item определение $e$ не компилируется (например, примените алгоритм W и покажите шаг, где он выведет ошибку).
\end{enumerate}

\end{enumerate}

\end{document}
